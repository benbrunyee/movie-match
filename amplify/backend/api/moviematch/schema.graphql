# Lamdba Functions

type Mutation {
  acceptRequest(input: AcceptRequestInput!): AWSJSON
    @function(name: "movieMatchLambdaFunction-${env}")
    @auth(
      rules: [
        { allow: private, provider: iam }
        { allow: private, provider: userPools }
      ]
    )
}

# Models

type User
  @model(subscriptions: { level: off })
  @auth(
    rules: [
      { allow: owner, operations: [create, read, update] }
      { allow: private, provider: iam, operations: [read, update] }
    ]
  ) {
  id: ID! @primaryKey
  sub: ID!
  email: String!
  requests: [ConnectionRequest!] @hasMany
  likedMovies: [MovieReaction!] @hasMany
  movieMatches: [Movie!] @hasMany
  connectedUser: String
    @auth(
      rules: [
        { allow: owner, operations: [read] }
        # Only allow the lambda function to update this field
        { allow: private, provider: iam, operations: [read, update] }
      ]
    )
}

type ConnectionRequest
  @model
  @auth(
    rules: [
      {
        allow: owner
        ownerField: "sender"
        operations: [create, read, update, delete]
      }
      {
        allow: owner
        ownerField: "receiver"
        operations: [read, update, delete]
      }
      { allow: private, provider: iam, operations: [read, update, delete] }
    ]
  ) {
  id: ID! @primaryKey
  sender: ID!
  receiver: ID!
  status: ConnectionRequestStatus!
}

type Movie
  @model
  @auth(
    rules: [
      { allow: owner, operations: [create] }
      { allow: private, provider: iam }
    ]
  ) {
  id: ID! @primaryKey
  name: String!
  identifier: String!
  coverUri: String
  rating: Int
  ratingCount: Int
  description: String!
  categories: [String!]!
  trailerUri: String
}

type MovieReaction
  @model
  @auth(rules: [{ allow: owner }, { allow: private, provider: iam }]) {
  id: ID! @primaryKey
  movie: Movie! @hasOne
  reaction: Reaction!
}

# Inputs

input AcceptRequestInput {
  requestId: ID!
}

# Enums

enum ConnectionRequestStatus {
  PENDING
  ACCEPTED
}

enum Reaction {
  LIKE
  DISLIKE
}
